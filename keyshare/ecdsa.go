// The Licensed Work is (c) 2022 Sygma
// SPDX-License-Identifier: LGPL-3.0-only

package keyshare

import (
	"encoding/json"
	"fmt"
	"os"
	"sync"

	"github.com/binance-chain/tss-lib/ecdsa/keygen"
	"github.com/libp2p/go-libp2p/core/peer"
)

// Keyshare stores key received from keygen or resharing
// and treshold and peers from current signing committee
type ECDSAKeyshare struct {
	Key       keygen.LocalPartySaveData
	Threshold int
	Peers     []peer.ID
}

func NewECDSAKeyshare(key keygen.LocalPartySaveData, threshold int, peers []peer.ID) ECDSAKeyshare {
	return ECDSAKeyshare{
		Key:       key,
		Threshold: threshold,
		Peers:     peers,
	}
}

type ECDSAKeyshareStore struct {
	mu   sync.Mutex
	path string
}

func NewECDSAKeyshareStore(filePath string) *ECDSAKeyshareStore {
	return &ECDSAKeyshareStore{
		path: filePath,
	}
}

// LockKeyshare locks keyshare from reading and writing to
// prevent keygen or resharing being done in parallel with other
// tss processes.
func (ks *ECDSAKeyshareStore) LockKeyshare() {
	ks.mu.Lock()
}

// UnlockKeyshare unlocks keyshare to allow for tss processes to continue
func (ks *ECDSAKeyshareStore) UnlockKeyshare() {
	ks.mu.Unlock()
}

// StoreKeyshare stores keyshare generated by keygen or reshare into file and truncates
// old keyshare.
func (ks *ECDSAKeyshareStore) StoreKeyshare(keyshare ECDSAKeyshare) error {
	f, err := os.OpenFile(ks.path, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)
	if err != nil {
		return err
	}
	defer f.Close()

	kb, err := json.Marshal(&keyshare)
	if err != nil {
		return err
	}

	_, err = f.Write(kb)
	return err
}

// GetECDSAKeyshare fetches current keyshare from file.
// Can be a blocking call if keygen or resharing are pending.
func (ks *ECDSAKeyshareStore) GetKeyshare() (ECDSAKeyshare, error) {
	k := ECDSAKeyshare{}

	kb, err := os.ReadFile(ks.path)
	if err != nil {
		return k, fmt.Errorf("error on reading keyshare file: %s", err)
	}

	err = json.Unmarshal(kb, &k)
	if err != nil {
		return k, fmt.Errorf("error on unmarshaling keyshare file: %s", err)
	}

	return k, err
}
